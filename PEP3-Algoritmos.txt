1. Histograma

histograma(I: Imagen): arreglo
    n <- numFilas(I)
    m <- numColumnas(I)
    h <- crearArregloVacío(256)

    para i <- 1 hasta n:
        para j <- 1 hasta m:
            color <- I[i, j]
            h[color + 1] <- h[color + 1] + 1

    devolver(h)

2. Histograma normalizado

histogramaNormalizado(I: Imagen): arreglo
    n <- numFilas(I)
    m <- numColumnas(I)
    h <- histograma(I)

    total <- n*m

    para i <- 1 hasta total:
        h[i] <- h[i]/total
    
    devolver(h)

3. Histograma acumulado

histogramaAcumulado(I: Imagen): arreglo
    h <- histograma(I)

    hA <- crearArregloVacío(256)

    hA[1] <- 0

    para i <- 2 hasta largo(h):
        hA[i] <- hA[i - 1] + h[i-1]

    devolver(hA)

4. Negativo

negativo(I: Imagen): arreglo
    n <- numFilas(I)
    m <- numColumnas(I)

    para i <- 1 hasta n:
        para j <- hasta m:
            I[i, j] <- 255 - I[i, j]

    devolver(I)

5. Blending

blending(I1: Imagen, I2: Imagen, a: flotante): Imagen
    si(numFilas(I1) != numFilas(I2) o numColumnas(I1) != numColumnas(I2)):
        no se puede hacer blending
    
    I <- nuevaImagen(numFilas(I1), numColumnas(I2))

    n <- numFilas(I1)
    m <- numColumnas(I1)

    para i <- 1 hasta n:
        para j <- 1 hasta m:
            colorA <- I1[i, j] * a
            colorB <- I2[i, j] * (1 - a)
            I[i, j] <- colorA + colorB

    devolver(I)

6. Histograma normalizado acumulado

histogramaNormalizadoAcumulado(I: Imagen): arreglo
    n <- numFilas(I)
    m <- numColumnas(I)
    total <- n*m

    hA <- histogramaAcumulado(I)

    para i <- 1 hasta largo(hA):
        hA[i] <- hA[i]/total
    
    devolver(hA)

7. Algoritmo de Otsu

umbralOtsu(I: Imagen): número
    hNA <- histogramaNormalizadoAcumulado(I)
    hN <- histogramaNormalizado(I)
    hA <- histogramaAcumulado(I)
    h <- histograma(I)

    sumaFondo <- 0
    pesoFondo <- 0
    varianzaMaxima <- 0
    umbral <- 0

    para i <- 1 hasta largo(hN):
        pesoFrente <- 1 - hNA[i]

        si h[i] == 0 o pesoFrente == 0:
            continuar
        
        sumaFondo <- i * hN[i]

        mediaFondo = sumaFondo / pesoFondo
        mediaFrente = (sumaTotal - sumaFondo) / pesoFrente

        varianzaEntre = pesoFondo * pesoFrente * (mediaFondo - mediaFrente) * (mediaFondo - mediaFrente)

        si varianzaEntre > varianzaMaxima:
            varianzaMaxima = varianzaEntre
            umbral = i

        devolver(umbral)

otsu(I: Imagen): Imagen
    umbral <- umbralOtsu(I)
    
    n <- numFilas(I)
    m <- numColumnas(I)

    para i <- 1 hasta n:
        para j <- 1 hasta m:
            si I[i, j] < umbral:
                I[i, j] <- 0
            si no:
                I[i, j] <- 255
    
    devolver(I)

8. ISODATA

isodata(I: Imagen, iteracionesMáximas: número): Imagen
    umbral <- mediaIntensidades(I)
    cambio <- True
    iteraciones <- 0

    clusterFondo <- crearArregloVacío(0)
    clusterObjeto <- crearArregloVacío(0)

    n <- numFilas(I)
    m <- numColumnas(I)

    mientras cambio e iteraciones < iteracionesMáximas:
        cambio = False
        iteraciones++

        para i <- 1 hasta n:
            para j <- 1 hasta m:
                si I[i, j] < umbral:
                    clusterFondo.push(I[i, j])
                si no:
                    clusterObjeto.push(I[i, j])

        mediaFondo <- mediaIntensidades(clusterFondo)
        mediaObjeto <- mediaIntensidades(clusterObjeto)

        nuevoUmbral <- (mediaFondo + mediaObjeto) / 2

        si abs(nuevoUmbral - umbral) > 0:
            cambio = True
            umbral = nuevoUmbral
        si no:
            iteraciones <- iteracionesMáximas

    para i <- 1 hasta n:
        para j <- 1 hasta m:
            si I[i, j] < umbral:
                I[i, j] <- 0
            si no:
                I[i, j] <- 255

    retornar(I)

9. Binarización adaptativa 

binarizacionAdaptativa(I: imagen, t: Ventana, c: número)
    IB <- crearImagen(numFilas(I), numColumnas(I))

    n <- numFilas(I)
    m <- numColumnas(I)

    para i <- 1 hasta n:
        para j <- 1 hasta m:
            x1 <- max(j - tamanoVentana(t) / 2, 1)
            y1 <- max(i - tamanoVentana(t) / 2, 1)
            x2 <- min(j + tamanoVentana(t) / 2, numColumnas(I) - 1)
            y2 <- min(i + tamanoVentana(t) / 2, numFilas(I) - 1)

            ventanaLocal <- extraerVentana(I, x1, y1, x2, y2)

            umbralLocal <- media(ventanaLocal) - c

            si I[i, j] > umbralLocal:
                IB[i, j] <- 255
            si no:
                IB[i, j] <- 0
                
    retornar(IB)

10. Correlación

11. Convolución
(Incluir casos donde se agrega un valor constante en los bordes,
se replica la columna/fila más próxima, reflexión o un wrap)


12. Filtro promedio

13. Filtro promedio ponderado

14. Filtro gaussiano

15. Filtro promedio de rango

16. Filtro mediana

17. Difusión anisotrópica

18. Detección de bordes

19. Operador de Prewitt

20. Operador de Sobel

21. Método de Canny

22. Operador Laplaciano

23. Laplaciano de gaussiano

24. Aplicación del zero-crossing

25. Operadores de Kirsch (direccionales)

26. Dilatación binaria

27. Erosión binaria

28. Apertura binaria

29. Clausura binaria

30. Dilatación

31. Erosión

32. Conectividad de componentes

33. Número de componentes

34. Corrección gamma

35. Escalamiento lineal

36. Ecualización de histograma

37. Adaptative Histogram Equalization AHE

38. Ecualización del histograma por LEVEL-SETs