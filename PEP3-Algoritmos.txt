1. Histograma

histograma(I: Imagen): arreglo
    n <- numFilas(I)
    m <- numColumnas(I)
    h <- crearArregloVacío(256)

    para i <- 1 hasta n:
        para j <- 1 hasta m:
            color <- I[i, j]
            h[color + 1] <- h[color + 1] + 1

    devolver(h)

2. Histograma normalizado

histogramaNormalizado(I: Imagen): arreglo
    n <- numFilas(I)
    m <- numColumnas(I)
    h <- histograma(I)

    total <- n*m

    para i <- 1 hasta total:
        h[i] <- h[i]/total
    
    devolver(h)

3. Histograma acumulado

histogramaAcumulado(I: Imagen): arreglo
    h <- histograma(I)

    hA <- crearArregloVacío(256)

    hA[1] <- 0

    para i <- 2 hasta largo(h):
        hA[i] <- hA[i - 1] + h[i-1]

    devolver(hA)

4. Negativo

negativo(I: Imagen): arreglo
    n <- numFilas(I)
    m <- numColumnas(I)

    para i <- 1 hasta n:
        para j <- hasta m:
            I[i, j] <- 255 - I[i, j]

    devolver(I)

5. Blending

blending(I1: Imagen, I2: Imagen, a: flotante): Imagen
    si(numFilas(I1) != numFilas(I2) o numColumnas(I1) != numColumnas(I2)):
        no se puede hacer blending
    
    I <- nuevaImagen(numFilas(I1), numColumnas(I2))

    n <- numFilas(I1)
    m <- numColumnas(I1)

    para i <- 1 hasta n:
        para j <- 1 hasta m:
            colorA <- I1[i, j] * a
            colorB <- I2[i, j] * (1 - a)
            I[i, j] <- colorA + colorB

    devolver(I)

6. Histograma normalizado acumulado

histogramaNormalizadoAcumulado(I: Imagen): arreglo
    n <- numFilas(I)
    m <- numColumnas(I)
    total <- n*m

    hA <- histogramaAcumulado(I)

    para i <- 1 hasta largo(hA):
        hA[i] <- hA[i]/total
    
    devolver(hA)

7. Algoritmo de Otsu

umbralOtsu(I: Imagen): número
    hNA <- histogramaNormalizadoAcumulado(I)
    hN <- histogramaNormalizado(I)
    hA <- histogramaAcumulado(I)
    h <- histograma(I)

    sumaFondo <- 0
    pesoFondo <- 0
    varianzaMaxima <- 0
    umbral <- 0

    para i <- 1 hasta largo(hN):
        pesoFrente <- 1 - hNA[i]

        si h[i] == 0 o pesoFrente == 0:
            continuar
        
        sumaFondo <- i * hN[i]

        mediaFondo = sumaFondo / pesoFondo
        mediaFrente = (sumaTotal - sumaFondo) / pesoFrente

        varianzaEntre = pesoFondo * pesoFrente * (mediaFondo - mediaFrente) * (mediaFondo - mediaFrente)

        si varianzaEntre > varianzaMaxima:
            varianzaMaxima = varianzaEntre
            umbral = i

        devolver(umbral)

otsu(I: Imagen): Imagen
    umbral <- umbralOtsu(I)
    
    n <- numFilas(I)
    m <- numColumnas(I)

    para i <- 1 hasta n:
        para j <- 1 hasta m:
            si I[i, j] < umbral:
                I[i, j] <- 0
            si no:
                I[i, j] <- 255
    
    devolver(I)

8. ISODATA

isodata(I: Imagen, iteracionesMáximas: número): Imagen
    umbral <- mediaIntensidades(I)
    cambio <- True
    iteraciones <- 0

    clusterFondo <- crearArregloVacío(0)
    clusterObjeto <- crearArregloVacío(0)

    n <- numFilas(I)
    m <- numColumnas(I)

    mientras cambio e iteraciones < iteracionesMáximas:
        cambio = False
        iteraciones++

        para i <- 1 hasta n:
            para j <- 1 hasta m:
                si I[i, j] < umbral:
                    clusterFondo.push(I[i, j])
                si no:
                    clusterObjeto.push(I[i, j])

        mediaFondo <- mediaIntensidades(clusterFondo)
        mediaObjeto <- mediaIntensidades(clusterObjeto)

        nuevoUmbral <- (mediaFondo + mediaObjeto) / 2

        si abs(nuevoUmbral - umbral) > 0:
            cambio = True
            umbral = nuevoUmbral
        si no:
            iteraciones <- iteracionesMáximas

    para i <- 1 hasta n:
        para j <- 1 hasta m:
            si I[i, j] < umbral:
                I[i, j] <- 0
            si no:
                I[i, j] <- 255

    retornar(I)

9. Binarización adaptativa 

binarizacionAdaptativa(I: imagen, t: Ventana, c: número)
    IB <- crearImagen(numFilas(I), numColumnas(I))

    n <- numFilas(I)
    m <- numColumnas(I)

    para i <- 1 hasta n:
        para j <- 1 hasta m:
            x1 <- max(j - tamanoVentana(t) / 2, 1)
            y1 <- max(i - tamanoVentana(t) / 2, 1)
            x2 <- min(j + tamanoVentana(t) / 2, numColumnas(I) - 1)
            y2 <- min(i + tamanoVentana(t) / 2, numFilas(I) - 1)

            ventanaLocal <- extraerVentana(I, x1, y1, x2, y2)

            umbralLocal <- media(ventanaLocal) - c

            si I[i, j] > umbralLocal:
                IB[i, j] <- 255
            si no:
                IB[i, j] <- 0

    retornar(IB)

10. Correlación



11. Convolución
(Incluir casos donde se agrega un valor constante en los bordes,
se replica la columna/fila más próxima, reflexión o un wrap)

convolucion(I: Imagen, M: Máscara): Imagen
    n <- numFilas(I)
    m <- numColumnas(I)

    a <- numFilas(M)
    b <- numColumnas(M)

    margenAltura <- a / 2
    margenAnchura <- b / 2

    IS <- nuevaImagen(n, m)

    // Se realiza la Convolución
    para i <- 1 hasta n - margenAltura:
        para j <- 1 hasta m - margenAnchura:
            suma <- 0

            para c <- 1 hasta a: 
                para d <- 1 hasta b:
                    si i - margenAltura <= 0 o j - margenAltura <= 0:
                        suma <- suma + M[c, d]
                    sino:
                        suma <- suma + M[c, d] * I[i - margenAltura, j - margenAnchura]


            IS[i, j] <- suma

    retornar(IS)

12. Filtro promedio

filtroPromedio(I: Imagen, M: Máscara): Imagen
    n <- numFilas(I)
    m <- numColumnas(I)

    a <- numFilas(M)
    b <- numColumnas(M)

    margenAltura <- a / 2
    margenAnchura <- b / 2

    IS <- nuevaImagen(n, m)

    para i <- 1 hasta n - margenAltura:
        para j <- 1 hasta m - margenAnchura:
            suma <- 0

            para c <- 1 hasta a: 
                para d <- 1 hasta b:
                    si i - margenAltura <= 0 o j - margenAltura <= 0:
                        suma <- suma + M[c, d]
                    sino:
                        suma <- suma + M[c, d] * I[i - margenAltura, j - margenAnchura]


            IS[i, j] <- suma / (a * b)

    retornar(IS)

13. Filtro promedio ponderado

filtroPromedioPonderado(I: Imagen, M: Máscara): Imagen
    n <- numFilas(I)
    m <- numColumnas(I)

    a <- numFilas(M)
    b <- numColumnas(M)

    margenAltura <- a / 2
    margenAnchura <- b / 2

    IS <- nuevaImagen(n, m)

    para i <- 1 hasta n - margenAltura:
        para j <- 1 hasta m - margenAnchura:
            suma <- 0
            valorTotal <- 0

            para c <- 1 hasta a:
                para d <- 1 hasta b:
                    valorTotal <- valorTotal + M[c, d]

            para c <- 1 hasta a: 
                para d <- 1 hasta b:
                    si i - margenAltura <= 0 o j - margenAltura <= 0:
                        suma <- suma + M[c, d]

                    sino:
                        suma <- suma + M[c, d] * I[i - margenAltura, j - margenAnchura] / valorTotal

            IS[i, j] <- suma

    retornar(IS)

14. Filtro gaussiano 
// Lo mismo que ponderado, solo que se le agrega peso a los pixeles
// del centro.

15. Filtro promedio de rango
//Se promedian los valores mínimo y máximo dentro del rango dado
//dentro de la máscara.


16. Filtro mediana

17. Difusión anisotrópica

18. Operador de Roberts

operadorRoberts(I: Imagen): Imagen

    G <- crearImagen(numFilas(I), numColumnas(I))

    para i <- 1 hasta numFilas(I):
        para j <- 1 hasta numColumnas(I):
            ... asumiendo padding
            gx <- I[i, j] - I[i + 1, j + 1]
            gy <- I[i, j + 1] - I[i + 1, j]
            G[i, j] <- abs(gx) + abs(gy)
    
    devolver(G)

19. Operador de Prewitt

operadorPrewitt(I: Imagen): Imagen

    G <- crearImagen(numFilas(I), numColumnas(I))

    para i <- 1 hasta numFilas(I):
        para j <- 1 hasta numColumnas(I):
            ... asumiendo padding
            gx <- - I[i - 1, j - 1] -  I[i, j - 1] -  I[i + 1, j - 1]
                + I[i - 1, j + 1] + I[i, j + 1] + I[i + 1, j + 1]

            gy <- - I[i - 1, j - 1] - I[i - 1, j] - I[i - 1, j + 1]
                + I[i + 1, j - 1] + I[i + 1, j] + I[i + 1, j + 1] 

            G[i, j] <- abs(gx) + abs(gy)

    devolver(G)

20. Operador de Sobel

operadorSobel(I: Imagen): Imagen

    /* 
    
    Asumiendo:

    Gx = [
           -1  -2  -1
            0   0   0
            1   2   1 
                        ]

    Gy = [
           -1   0   1
           -2   0   2
           -1   0   1
                        ]
    */

    G <- crearImagen(numFilas(I), numColumnas(I))

    para i <- 1 hasta numFilas(I):
        para j <- 1 hasta numColumnas(I):
            ... asumiendo padding
            gx <- - I[i - 1, j - 1] - 2 * I[i, j - 1] - I[i + 1, j - 1]
                + I[i - 1, j + 1] + 2 * I[i, j + 1] + I[i + 1, j + 1]

            gy <- - I[i - 1, j - 1] - 2 * I[i - 1, j] - I[i - 1, j + 1]
                + I[i + 1, j - 1] + 2 * I[i + 1, j] + I[i + 1, j + 1] 

            G[i, j] <- abs(gx) + abs(gy)

    devolver(G)

PD: Recordar que los coeficientes que multiplican a la imagen pueden
cambiar según el tipo de máscara. 

21. Método de Canny

metodoCanny(I: Imagen): Imagen
    I <- filtroGaussiano(I)



22. Operador Laplaciano

23. Laplaciano de gaussiano

24. Aplicación del zero-crossing

25. Operadores de Kirsch (direccionales)

26. Dilatación binaria

dilatacionBinaria(I: Imagen, E: Elemento estructural): Imagen

    G <- crearImagen(numFilas(I), numColumnas(I))

    para i <- 1 hasta numFilas(I):
        para j <- 1 hasta numColumnas(I):
            
            si centro(E) == I[i, j] y centro(E) == 0:
                para a <- 1 hasta numFilas(E):
                    para b <- 1 hasta numColumnas(E):
                        si I[i, j] != E[a, b] y E[a, b] == 0:
                            G[i + a, j + b] = 0

    devolver(G)
                

27. Erosión binaria

28. Apertura binaria

29. Clausura binaria

30. Dilatación

31. Erosión

32. Conectividad de componentes

33. Número de componentes

34. Corrección gamma

35. Escalamiento lineal

36. Ecualización de histograma

37. Adaptative Histogram Equalization AHE

38. Ecualización del histograma por LEVEL-SETs